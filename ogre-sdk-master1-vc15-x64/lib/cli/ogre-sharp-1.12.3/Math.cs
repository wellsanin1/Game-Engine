//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.12
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace org.ogre {

public class Math : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal Math(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Math obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~Math() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          OgrePINVOKE.delete_Math(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  public class RandomValueProvider : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal RandomValueProvider(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(RandomValueProvider obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    ~RandomValueProvider() {
      Dispose();
    }
  
    public virtual void Dispose() {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            OgrePINVOKE.delete_Math_RandomValueProvider(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
        global::System.GC.SuppressFinalize(this);
      }
    }
  
    public virtual float getRandomUnit() {
      float ret = OgrePINVOKE.Math_RandomValueProvider_getRandomUnit(swigCPtr);
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  
  }

  public Math(uint trigTableSize) : this(OgrePINVOKE.new_Math__SWIG_0(trigTableSize), true) {
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
  }

  public Math() : this(OgrePINVOKE.new_Math__SWIG_1(), true) {
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
  }

  public static int IAbs(int iValue) {
    int ret = OgrePINVOKE.Math_IAbs(iValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static int ICeil(float fValue) {
    int ret = OgrePINVOKE.Math_ICeil(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static int IFloor(float fValue) {
    int ret = OgrePINVOKE.Math_IFloor(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static int ISign(int iValue) {
    int ret = OgrePINVOKE.Math_ISign(iValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Abs(float fValue) {
    float ret = OgrePINVOKE.Math_Abs__SWIG_0(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Degree Abs(Degree dValue) {
    Degree ret = new Degree(OgrePINVOKE.Math_Abs__SWIG_1(Degree.getCPtr(dValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian Abs(Radian rValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_Abs__SWIG_2(Radian.getCPtr(rValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian ACos(float fValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_ACos(fValue), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian ASin(float fValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_ASin(fValue), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian ATan(float fValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_ATan(fValue), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian ATan2(float fY, float fX) {
    Radian ret = new Radian(OgrePINVOKE.Math_ATan2(fY, fX), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Ceil(float fValue) {
    float ret = OgrePINVOKE.Math_Ceil(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool isNaN(float f) {
    bool ret = OgrePINVOKE.Math_isNaN(f);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Cos(Radian fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Cos__SWIG_0(Radian.getCPtr(fValue), useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Cos(Radian fValue) {
    float ret = OgrePINVOKE.Math_Cos__SWIG_1(Radian.getCPtr(fValue));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Cos(float fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Cos__SWIG_2(fValue, useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Cos(float fValue) {
    float ret = OgrePINVOKE.Math_Cos__SWIG_3(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Exp(float fValue) {
    float ret = OgrePINVOKE.Math_Exp(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Floor(float fValue) {
    float ret = OgrePINVOKE.Math_Floor(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Log(float fValue) {
    float ret = OgrePINVOKE.Math_Log(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float LOG2 {
    get {
      float ret = OgrePINVOKE.Math_LOG2_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float Log2(float fValue) {
    float ret = OgrePINVOKE.Math_Log2(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float LogN(float arg0, float fValue) {
    float ret = OgrePINVOKE.Math_LogN(arg0, fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Pow(float fBase, float fExponent) {
    float ret = OgrePINVOKE.Math_Pow(fBase, fExponent);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sign(float fValue) {
    float ret = OgrePINVOKE.Math_Sign__SWIG_0(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian Sign(Radian rValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_Sign__SWIG_1(Radian.getCPtr(rValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Degree Sign(Degree dValue) {
    Degree ret = new Degree(OgrePINVOKE.Math_Sign__SWIG_2(Degree.getCPtr(dValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float saturate(float t) {
    float ret = OgrePINVOKE.Math_saturate__SWIG_0(t);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static double saturate(double t) {
    double ret = OgrePINVOKE.Math_saturate__SWIG_1(t);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static ushort uint16Cast(uint t) {
    ushort ret = OgrePINVOKE.Math_uint16Cast(t);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sin(Radian fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Sin__SWIG_0(Radian.getCPtr(fValue), useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sin(Radian fValue) {
    float ret = OgrePINVOKE.Math_Sin__SWIG_1(Radian.getCPtr(fValue));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sin(float fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Sin__SWIG_2(fValue, useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sin(float fValue) {
    float ret = OgrePINVOKE.Math_Sin__SWIG_3(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sqr(float fValue) {
    float ret = OgrePINVOKE.Math_Sqr(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Sqrt(float fValue) {
    float ret = OgrePINVOKE.Math_Sqrt__SWIG_0(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Radian Sqrt(Radian fValue) {
    Radian ret = new Radian(OgrePINVOKE.Math_Sqrt__SWIG_1(Radian.getCPtr(fValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Degree Sqrt(Degree fValue) {
    Degree ret = new Degree(OgrePINVOKE.Math_Sqrt__SWIG_2(Degree.getCPtr(fValue)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float InvSqrt(float fValue) {
    float ret = OgrePINVOKE.Math_InvSqrt(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float UnitRandom() {
    float ret = OgrePINVOKE.Math_UnitRandom();
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float RangeRandom(float fLow, float fHigh) {
    float ret = OgrePINVOKE.Math_RangeRandom(fLow, fHigh);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float SymmetricRandom() {
    float ret = OgrePINVOKE.Math_SymmetricRandom();
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void SetRandomValueProvider(Math.RandomValueProvider provider) {
    OgrePINVOKE.Math_SetRandomValueProvider(Math.RandomValueProvider.getCPtr(provider));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
  }

  public static float Tan(Radian fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Tan__SWIG_0(Radian.getCPtr(fValue), useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Tan(Radian fValue) {
    float ret = OgrePINVOKE.Math_Tan__SWIG_1(Radian.getCPtr(fValue));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Tan(float fValue, bool useTables) {
    float ret = OgrePINVOKE.Math_Tan__SWIG_2(fValue, useTables);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float Tan(float fValue) {
    float ret = OgrePINVOKE.Math_Tan__SWIG_3(fValue);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float DegreesToRadians(float degrees) {
    float ret = OgrePINVOKE.Math_DegreesToRadians(degrees);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float RadiansToDegrees(float radians) {
    float ret = OgrePINVOKE.Math_RadiansToDegrees(radians);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static void setAngleUnit(Math.AngleUnit unit) {
    OgrePINVOKE.Math_setAngleUnit((int)unit);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
  }

  public static Math.AngleUnit getAngleUnit() {
    Math.AngleUnit ret = (Math.AngleUnit)OgrePINVOKE.Math_getAngleUnit();
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float AngleUnitsToRadians(float units) {
    float ret = OgrePINVOKE.Math_AngleUnitsToRadians(units);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float RadiansToAngleUnits(float radians) {
    float ret = OgrePINVOKE.Math_RadiansToAngleUnits(radians);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float AngleUnitsToDegrees(float units) {
    float ret = OgrePINVOKE.Math_AngleUnitsToDegrees(units);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float DegreesToAngleUnits(float degrees) {
    float ret = OgrePINVOKE.Math_DegreesToAngleUnits(degrees);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool pointInTri2D(Vector2 p, Vector2 a, Vector2 b, Vector2 c) {
    bool ret = OgrePINVOKE.Math_pointInTri2D(Vector2.getCPtr(p), Vector2.getCPtr(a), Vector2.getCPtr(b), Vector2.getCPtr(c));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool pointInTri3D(Vector3 p, Vector3 a, Vector3 b, Vector3 c, Vector3 normal) {
    bool ret = OgrePINVOKE.Math_pointInTri3D(Vector3.getCPtr(p), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Plane plane) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_0(Ray.getCPtr(ray), Plane.getCPtr(plane)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Sphere sphere, bool discardInside) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_1(Ray.getCPtr(ray), Sphere.getCPtr(sphere), discardInside), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Sphere sphere) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_2(Ray.getCPtr(ray), Sphere.getCPtr(sphere)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, AxisAlignedBox box) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_3(Ray.getCPtr(ray), AxisAlignedBox.getCPtr(box)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool intersects(Ray ray, AxisAlignedBox box, SWIGTYPE_p_float d1, SWIGTYPE_p_float d2) {
    bool ret = OgrePINVOKE.Math_intersects__SWIG_4(Ray.getCPtr(ray), AxisAlignedBox.getCPtr(box), SWIGTYPE_p_float.getCPtr(d1), SWIGTYPE_p_float.getCPtr(d2));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal, bool positiveSide, bool negativeSide) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_5(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal), positiveSide, negativeSide), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal, bool positiveSide) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_6(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal), positiveSide), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_7(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), Vector3.getCPtr(normal)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, bool positiveSide, bool negativeSide) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_8(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), positiveSide, negativeSide), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, bool positiveSide) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_9(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c), positiveSide), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_10(Ray.getCPtr(ray), Vector3.getCPtr(a), Vector3.getCPtr(b), Vector3.getCPtr(c)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool intersects(Sphere sphere, AxisAlignedBox box) {
    bool ret = OgrePINVOKE.Math_intersects__SWIG_11(Sphere.getCPtr(sphere), AxisAlignedBox.getCPtr(box));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool intersects(Plane plane, AxisAlignedBox box) {
    bool ret = OgrePINVOKE.Math_intersects__SWIG_12(Plane.getCPtr(plane), AxisAlignedBox.getCPtr(box));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, SWIGTYPE_p_std__vectorT_Ogre__Plane_t planeList, bool normalIsOutside) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_13(Ray.getCPtr(ray), SWIGTYPE_p_std__vectorT_Ogre__Plane_t.getCPtr(planeList), normalIsOutside), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, SWIGTYPE_p_std__listT_Ogre__Plane_t planeList, bool normalIsOutside) {
    SWIGTYPE_p_std__pairT_bool_float_t ret = new SWIGTYPE_p_std__pairT_bool_float_t(OgrePINVOKE.Math_intersects__SWIG_14(Ray.getCPtr(ray), SWIGTYPE_p_std__listT_Ogre__Plane_t.getCPtr(planeList), normalIsOutside), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool intersects(Sphere sphere, Plane plane) {
    bool ret = OgrePINVOKE.Math_intersects__SWIG_15(Sphere.getCPtr(sphere), Plane.getCPtr(plane));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool RealEqual(float a, float b, float tolerance) {
    bool ret = OgrePINVOKE.Math_RealEqual__SWIG_0(a, b, tolerance);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool RealEqual(float a, float b) {
    bool ret = OgrePINVOKE.Math_RealEqual__SWIG_1(a, b);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 calculateTangentSpaceVector(Vector3 position1, Vector3 position2, Vector3 position3, float u1, float v1, float u2, float v2, float u3, float v3) {
    Vector3 ret = new Vector3(OgrePINVOKE.Math_calculateTangentSpaceVector(Vector3.getCPtr(position1), Vector3.getCPtr(position2), Vector3.getCPtr(position3), u1, v1, u2, v2, u3, v3), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Affine3 buildReflectionMatrix(Plane p) {
    Affine3 ret = new Affine3(OgrePINVOKE.Math_buildReflectionMatrix(Plane.getCPtr(p)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector4 calculateFaceNormal(Vector3 v1, Vector3 v2, Vector3 v3) {
    Vector4 ret = new Vector4(OgrePINVOKE.Math_calculateFaceNormal(Vector3.getCPtr(v1), Vector3.getCPtr(v2), Vector3.getCPtr(v3)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 calculateBasicFaceNormal(Vector3 v1, Vector3 v2, Vector3 v3) {
    Vector3 ret = new Vector3(OgrePINVOKE.Math_calculateBasicFaceNormal(Vector3.getCPtr(v1), Vector3.getCPtr(v2), Vector3.getCPtr(v3)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector4 calculateFaceNormalWithoutNormalize(Vector3 v1, Vector3 v2, Vector3 v3) {
    Vector4 ret = new Vector4(OgrePINVOKE.Math_calculateFaceNormalWithoutNormalize(Vector3.getCPtr(v1), Vector3.getCPtr(v2), Vector3.getCPtr(v3)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Vector3 calculateBasicFaceNormalWithoutNormalize(Vector3 v1, Vector3 v2, Vector3 v3) {
    Vector3 ret = new Vector3(OgrePINVOKE.Math_calculateBasicFaceNormalWithoutNormalize(Vector3.getCPtr(v1), Vector3.getCPtr(v2), Vector3.getCPtr(v3)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float gaussianDistribution(float x, float offset, float scale) {
    float ret = OgrePINVOKE.Math_gaussianDistribution__SWIG_0(x, offset, scale);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float gaussianDistribution(float x, float offset) {
    float ret = OgrePINVOKE.Math_gaussianDistribution__SWIG_1(x, offset);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float gaussianDistribution(float x) {
    float ret = OgrePINVOKE.Math_gaussianDistribution__SWIG_2(x);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Affine3 makeViewMatrix(Vector3 position, Quaternion orientation, Affine3 reflectMatrix) {
    Affine3 ret = new Affine3(OgrePINVOKE.Math_makeViewMatrix__SWIG_0(Vector3.getCPtr(position), Quaternion.getCPtr(orientation), Affine3.getCPtr(reflectMatrix)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Affine3 makeViewMatrix(Vector3 position, Quaternion orientation) {
    Affine3 ret = new Affine3(OgrePINVOKE.Math_makeViewMatrix__SWIG_1(Vector3.getCPtr(position), Quaternion.getCPtr(orientation)), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Matrix4 makePerspectiveMatrix(float left, float right, float bottom, float top, float zNear, float zFar) {
    Matrix4 ret = new Matrix4(OgrePINVOKE.Math_makePerspectiveMatrix(left, right, bottom, top, zNear, zFar), true);
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float boundingRadiusFromAABB(AxisAlignedBox aabb) {
    float ret = OgrePINVOKE.Math_boundingRadiusFromAABB(AxisAlignedBox.getCPtr(aabb));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float boundingRadiusFromAABBCentered(AxisAlignedBox aabb) {
    float ret = OgrePINVOKE.Math_boundingRadiusFromAABBCentered(AxisAlignedBox.getCPtr(aabb));
    if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static float POS_INFINITY {
    get {
      float ret = OgrePINVOKE.Math_POS_INFINITY_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float NEG_INFINITY {
    get {
      float ret = OgrePINVOKE.Math_NEG_INFINITY_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float PI {
    get {
      float ret = OgrePINVOKE.Math_PI_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float TWO_PI {
    get {
      float ret = OgrePINVOKE.Math_TWO_PI_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float HALF_PI {
    get {
      float ret = OgrePINVOKE.Math_HALF_PI_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float fDeg2Rad {
    get {
      float ret = OgrePINVOKE.Math_fDeg2Rad_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static float fRad2Deg {
    get {
      float ret = OgrePINVOKE.Math_fRad2Deg_get();
      if (OgrePINVOKE.SWIGPendingException.Pending) throw OgrePINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public enum AngleUnit {
    AU_DEGREE,
    AU_RADIAN
  }

}

}
